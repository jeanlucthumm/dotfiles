#!/usr/bin/env python3

from __future__ import print_function

import json
import subprocess
import sys
import os
import os.path

# Hook should extract all of the following for use as Timewarrior tags:
#   UUID
#   Project
#   Tags
#   Description
#   UDAs

try:
    input_stream = sys.stdin.buffer
except AttributeError:
    input_stream = sys.stdin

# Make no changes to the task, simply observe.
old = json.loads(input_stream.readline().decode("utf-8", errors="replace"))
new = json.loads(input_stream.readline().decode("utf-8", errors="replace"))
print(json.dumps(new))


def extract_tags_from(json_obj):
    ## Only care about project as tag
    tags = []

    # Extract attributes for use as tags.
    # tags.append(json_obj['description']]

    if "project" in json_obj:
        tags.append(json_obj["project"])

    # if 'tags' in json_obj:
    #     tags.extend(json_obj['tags'])

    return tags


def extract_annotation_from(json_obj):

    if "annotations" not in json_obj:
        return "''"

    return json_obj["annotations"][0]["description"]


def has_other_active_tasks_with_project(project, current_uuid):
    """Check if there are other active tasks with the same project."""
    if not project:
        return False

    try:
        # Get all active tasks (tasks that have been started but not completed)
        result = subprocess.run(
            ["task", "status:pending", "start.any:", "export"],
            capture_output=True,
            text=True,
            check=True
        )

        if not result.stdout.strip():
            return False

        tasks = json.loads(result.stdout)

        # Check if any other task (not the current one) has the same project and is active
        for task in tasks:
            if (task.get("uuid") != current_uuid and
                task.get("project") == project and
                "start" in task and
                "end" not in task):
                return True

        return False
    except Exception:
        # If we can't determine, err on the side of not stopping the timer
        return True


start_or_stop = ""

# Started task.
if "start" in new and "start" not in old:
    start_or_stop = "start"

# Stopped task.
elif ("start" not in new or "end" in new) and "start" in old:
    # Only stop the timer if there are no other active tasks with the same project
    project = new.get("project")
    uuid = new.get("uuid")
    if not has_other_active_tasks_with_project(project, uuid):
        start_or_stop = "stop"

if start_or_stop:
    tags = extract_tags_from(new)
    subprocess.call(["timew", start_or_stop] + tags + [":yes"])

# Modifications to task other than start/stop
elif "start" in new and "start" in old:
    old_tags = extract_tags_from(old)
    new_tags = extract_tags_from(new)

    if old_tags != new_tags:
        subprocess.call(["timew", "untag", "@1"] + old_tags + [":yes"])
        subprocess.call(["timew", "tag", "@1"] + new_tags + [":yes"])

    old_annotation = extract_annotation_from(old)
    new_annotation = extract_annotation_from(new)

    if old_annotation != new_annotation:
        subprocess.call(["timew", "annotate", "@1", new_annotation])
